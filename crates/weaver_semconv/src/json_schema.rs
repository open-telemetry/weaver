// SPDX-License-Identifier: Apache-2.0

//! JSON Schema validator for semantic convention files.

use crate::semconv::SemConvSpec;
use crate::Error::{CompoundError, InvalidSemConvSpec, InvalidXPath};
use crate::{Error, InvalidSemConvSpecError};
use jsonschema::error::{TypeKind, ValidationErrorKind};
use jsonschema::{JsonType, JsonTypeSet};
use miette::{NamedSource, SourceSpan};
use saphyr::{LoadableYamlNode, MarkedYaml};
use std::borrow::Cow;

/// Parsed simple XPath components
#[derive(Debug, Clone)]
enum PathComponent {
    Key(String),
    Index(usize),
}

/// JSON schema validator for semantic conventions.
pub struct JsonSchemaValidator {
    /// The JSON schema for the semantic convention specification.
    json_schema: serde_json::Value,

    /// JSON schema validator instance
    validator: jsonschema::Validator,
}

impl Default for JsonSchemaValidator {
    fn default() -> Self {
        Self::new()
    }
}

impl JsonSchemaValidator {
    /// Creates a new JSON schema validator.
    #[must_use]
    pub fn new() -> Self {
        // Generate the JSON schema for the SemConvSpec struct using Schemars
        let root_schema = schemars::schema_for!(SemConvSpec);
        let json_schema = serde_json::to_value(&root_schema)
            // Should never happen as we expert Schemars to work
            .expect("Failed to convert schema to JSON value");
        let validator = jsonschema::Validator::new(&json_schema)
            // Should never happen as we expert Schemars to work
            .expect("Failed to create JSON schema validator");

        JsonSchemaValidator {
            json_schema,
            validator,
        }
    }

    /// Validates the given JSON schema against the provided schema.
    pub fn validate_yaml(
        &self,
        yaml_value: serde_yaml::Value,
        provenance: &str,
        serde_error: serde_yaml::Error,
    ) -> Result<(), Error> {
        // Convert YAML value to JSON value as the validator works with JSON
        let json = match serde_json::to_value(yaml_value) {
            Ok(v) => v,
            Err(_) => {
                // Fallback to original serde error
                return Err(Error::DeserializationError {
                    path_or_url: provenance.to_owned(),
                    error: serde_error.to_string(),
                });
            }
        };

        let mut errors = vec![];
        let yaml_doc = YamlDoc::try_from_file(provenance)?;

        // Iterate over errors generated by the validator
        for error in self.validator.iter_errors(&json) {
            let description = self.build_description_from_xpath(error.schema_path.as_str())?;
            let error_msg = self.build_error_message(&error);
            errors.push(InvalidSemConvSpec(Box::new(InvalidSemConvSpecError {
                src: NamedSource::new(provenance, yaml_doc.raw_yaml()),
                err_span: yaml_doc.source_span(error.instance_path.as_str())?,
                error: error_msg,
                advice: Some(description),
            })));
        }

        if errors.is_empty() {
            Ok(())
        } else if errors.len() == 1 {
            Err(errors
                .into_iter()
                .next()
                .expect("At least one error should be present"))
        } else {
            // If there are multiple errors, return a compound error
            Err(CompoundError(errors))
        }
    }

    /// Builds a nice error message from the validation error.
    fn build_error_message(&self, error: &jsonschema::ValidationError<'_>) -> String {
        match &error.kind {
            ValidationErrorKind::AdditionalItems { limit } =>
                format!("Array has more items ({}) than allowed (maximum: {}).", error.instance, limit),

            ValidationErrorKind::AdditionalProperties { unexpected } =>
                format!(
                    "Object contains unexpected properties: {}. These properties are not defined in the schema.",
                    unexpected.join(", ")
                ),

            ValidationErrorKind::AnyOf =>
                "The following YAML snippet does not match any of the allowed schemas (anyOf, see help section).".to_owned(),

            ValidationErrorKind::BacktrackLimitExceeded { error: e } =>
                format!("Regex match failed: backtrack limit exceeded ({})", e),

            ValidationErrorKind::Constant { expected_value } =>
                format!("Value {} does not match the required constant: {}.", error.instance, expected_value),

            ValidationErrorKind::Contains =>
                format!("Array {} does not contain any items matching the required schema.", error.instance),

            ValidationErrorKind::ContentEncoding { content_encoding } =>
                format!("Value {} does not conform to the required contentEncoding: '{}'.", error.instance, content_encoding),

            ValidationErrorKind::ContentMediaType { content_media_type } =>
                format!("Value {} does not conform to the required contentMediaType: '{}'.", error.instance, content_media_type),

            ValidationErrorKind::Custom { message } =>
                format!("Custom validation error: {}", message),

            ValidationErrorKind::Enum { options } =>
                format!("Value {} is not among the allowed options: {}.", error.instance, options),

            ValidationErrorKind::ExclusiveMaximum { limit } =>
                format!("Value {} must be less than {}.", error.instance, limit),

            ValidationErrorKind::ExclusiveMinimum { limit } =>
                format!("Value {} must be greater than {}.", error.instance, limit),

            ValidationErrorKind::FalseSchema =>
                format!("Schema is set to 'false'; all values are invalid (found {}).", error.instance),

            ValidationErrorKind::Format { format } =>
                format!("Value {} does not match the required format: '{}'.", error.instance, format),

            ValidationErrorKind::FromUtf8 { error: e } =>
                format!("Base64 or UTF-8 decoding failed: {}", e),

            ValidationErrorKind::MaxItems { limit } =>
                format!("Array {} has too many items: {} (maximum allowed is {}).", error.instance, error.instance, limit),

            ValidationErrorKind::Maximum { limit } =>
                format!("Value {} must be less than or equal to {}.", error.instance, limit),

            ValidationErrorKind::MaxLength { limit } =>
                format!("String {} is too long: exceeds the maximum length of {} character{}.",
                        error.instance, limit, if *limit == 1 { "" } else { "s" }),

            ValidationErrorKind::MaxProperties { limit } =>
                format!("Object {} has too many properties: exceeds the maximum of {} propert{}.",
                        error.instance, limit, if *limit == 1 { "y" } else { "ies" }),

            ValidationErrorKind::MinItems { limit } =>
                format!("Array {} has too few items: minimum required is {}.", error.instance, limit),

            ValidationErrorKind::Minimum { limit } =>
                format!("Value {} must be greater than or equal to {}.", error.instance, limit),

            ValidationErrorKind::MinLength { limit } =>
                format!("String {} is too short: must be at least {} character{}.",
                        error.instance, limit, if *limit == 1 { "" } else { "s" }),

            ValidationErrorKind::MinProperties { limit } =>
                format!("Object {} has too few properties: minimum required is {} propert{}.",
                        error.instance, limit, if *limit == 1 { "y" } else { "ies" }),

            ValidationErrorKind::MultipleOf { multiple_of } =>
                format!("Value {} is not a multiple of {}.", error.instance, multiple_of),

            ValidationErrorKind::Not { schema } =>
                format!("Value {} matches a schema that is explicitly forbidden (not). Schema: {}", error.instance, schema),

            ValidationErrorKind::OneOfMultipleValid =>
                format!("Value {} matches more than one schema in a 'oneOf' group; it must match exactly one.", error.instance),

            ValidationErrorKind::OneOfNotValid =>
                format!("Value {} does not match any schema in a 'oneOf' group; it must match exactly one.", error.instance),

            ValidationErrorKind::Pattern { pattern } =>
                format!("String {} does not match the required pattern: '{}'.", error.instance, pattern),

            ValidationErrorKind::PropertyNames { error: e } =>
                format!("Invalid object property name(s): {}", e),

            ValidationErrorKind::Required { property } =>
                format!("Missing required property: {}.", property),

            ValidationErrorKind::Type { kind: TypeKind::Single(type_) } =>
                format!("Value {} is not of the required type: '{}'.", error.instance, type_),

            ValidationErrorKind::Type { kind: TypeKind::Multiple(types) } =>
                format!("Value {} is not of any of the required types. {}.", error.instance, Self::describe_types(types)),

            ValidationErrorKind::UnevaluatedItems { unexpected } =>
                format!("Array contains unevaluated items that are not allowed: {}.", unexpected.join(", ")),

            ValidationErrorKind::UnevaluatedProperties { unexpected } =>
                format!("Object contains unevaluated properties that are not allowed: {}.", unexpected.join(", ")),

            ValidationErrorKind::UniqueItems =>
                format!("Array {} has duplicate (non-unique) items.", error.instance),

            ValidationErrorKind::Referencing(e) =>
                format!("Error resolving $ref: {}", e),
        }
    }

    /// Returns the description corresponding to the JSON schema XPath.
    fn build_description_from_xpath(&self, xpath: &str) -> Result<String, Error> {
        let path_components = parse_xpath(xpath)?;
        let mut current = &self.json_schema;
        let mut description = "No description available".to_owned();

        for component in path_components {
            if let Some(desc) = current.get("description") {
                if let Some(desc) = desc.as_str() {
                    description = desc.to_owned();
                }
            }

            match component {
                PathComponent::Key(key) => {
                    if let Some(v) = current.get(&key) {
                        if key == "$ref" {
                            // If the key is $ref, we need to resolve the reference
                            current = self.get_ref_definition(v.as_str().unwrap_or(""))?;
                        } else {
                            current = v;
                        }
                    } else {
                        return Err(InvalidXPath {
                            xpath: xpath.to_owned(),
                            error: format!("Key '{}' not found in JSON schema", key),
                        });
                    }
                }
                PathComponent::Index(index) => {
                    if let Some(v) = current.get(index) {
                        current = v;
                    } else {
                        return Err(InvalidXPath {
                            xpath: xpath.to_owned(),
                            error: format!("Index {} out of bounds in JSON schema", index),
                        });
                    }
                }
            }
        }

        Ok(description)
    }

    /// Retrieves the definition for a $ref path in the JSON schema.
    fn get_ref_definition(&self, ref_path: &str) -> Result<&serde_json::Value, Error> {
        // Extract the definition from the JSON schema using the $ref path
        let parts: Vec<&str> = ref_path.split('/').collect();
        if parts.len() < 2 || parts[0] != "#" {
            return Err(InvalidXPath {
                xpath: ref_path.to_owned(),
                error: "Invalid $ref path".to_owned(),
            });
        }

        let mut current = &self.json_schema;
        for part in &parts[1..] {
            if let Some(value) = current.get(part) {
                current = value;
            } else {
                return Err(InvalidXPath {
                    xpath: ref_path.to_owned(),
                    error: format!("No such reference: {}", part),
                });
            }
        }
        Ok(current)
    }

    fn describe_types(types: &JsonTypeSet) -> String {
        let mut type_names: Vec<String> = Vec::new();
        let mut has_null = false;

        for json_type in types.iter() {
            if json_type == JsonType::Null {
                has_null = true;
            } else {
                type_names.push(json_type.to_string());
            }
        }

        if has_null {
            type_names.push("null (i.e. optional)".to_owned());
        }

        if !type_names.is_empty() {
            format!("Supported types: {}", type_names.join(", "))
        } else {
            String::new()
        }
    }
}

/// Represents a position in the source file
#[derive(Debug, Clone, PartialEq, Default)]
struct Position {
    /// Line number (1-based)
    line: usize,
    /// Column number (1-based)
    column: usize,
    char_pos: usize,
}

/// Represents a block's boundaries in the source
#[derive(Debug, Clone, Default)]
struct BlockPosition {
    start: Position,
    end: Position,
}

struct YamlDoc {
    raw_yaml: Cow<'static, str>,
    marked_yaml: MarkedYaml<'static>,
    /// The byte offsets of each character in the raw YAML string.
    /// For the n-th character, `char_offsets[n]` is its starting byte position.
    char_offsets: Vec<usize>,
}

impl YamlDoc {
    /// Create a YamlDoc from a YAML file.
    fn try_from_file(path_or_url: &str) -> Result<Self, Error> {
        let raw_yaml =
            std::fs::read_to_string(path_or_url).map_err(|e| Error::DeserializationError {
                path_or_url: path_or_url.to_owned(),
                error: e.to_string(),
            })?;

        Self::try_from_string(&raw_yaml, path_or_url)
    }

    /// Create a YamlDoc from a YAML string.
    fn try_from_string(yaml: &str, path_or_url: &str) -> Result<Self, Error> {
        let raw_yaml: Cow<'static, str> = Cow::Owned(yaml.to_owned());

        let yaml_docs =
            MarkedYaml::load_from_str(yaml).map_err(|e| Error::DeserializationError {
                path_or_url: path_or_url.to_owned(),
                error: e.to_string(),
            })?;
        if yaml_docs.len() != 1 {
            return Err(Error::DeserializationError {
                path_or_url: path_or_url.to_owned(),
                error: "Expected exactly one YAML document".to_owned(),
            });
        }

        let char_offsets: Vec<usize> = yaml.char_indices().map(|(i, _)| i).collect();

        Ok(YamlDoc {
            raw_yaml,
            marked_yaml: yaml_docs
                .into_iter()
                .next()
                .expect("There should be exactly one YAML document"),
            char_offsets,
        })
    }

    /// Convert an XPath string to a BlockPosition in the YAML document
    fn xpath_to_block_position(&self, xpath: &str) -> Result<BlockPosition, Error> {
        let path_components = parse_xpath(xpath)?;
        let mut current = &self.marked_yaml;

        for component in &path_components {
            match component {
                PathComponent::Key(key) => {
                    // Navigate to the key in the YAML structure
                    if let Some(value) = current.data.as_mapping_get(key) {
                        current = value;
                    } else {
                        return Err(InvalidXPath {
                            xpath: xpath.to_owned(),
                            error: format!("Key '{}' not found in YAML document", key),
                        });
                    }
                }
                PathComponent::Index(index) => {
                    // Navigate to the index in the YAML sequence
                    if let Some(value) = current.data.as_sequence_get(*index) {
                        current = value;
                    } else {
                        return Err(InvalidXPath {
                            xpath: xpath.to_owned(),
                            error: format!("Index {} out of bounds in YAML document", index),
                        });
                    }
                }
            }
        }

        Ok(BlockPosition {
            start: Position {
                line: current.span.start.line(),
                column: current.span.start.col(),
                char_pos: current.span.start.index(),
            },
            end: Position {
                line: current.span.end.line(),
                column: current.span.end.col(),
                char_pos: current.span.end.index(),
            },
        })
    }

    fn source_span(&self, xpath: &str) -> Result<SourceSpan, Error> {
        let block_pos = self.xpath_to_block_position(xpath)?;
        Ok((
            self.char_offsets[block_pos.start.char_pos],
            self.char_offsets[block_pos.end.char_pos] - self.char_offsets[block_pos.start.char_pos],
        )
            .into())
        // println!("Block position: {}--{}", block_pos.start.char_pos, block_pos.end.char_pos);
        // if block_pos.start.char_pos != block_pos.end.char_pos {
        //     return Ok((
        //         self.char_offsets[block_pos.start.char_pos],
        //         self.char_offsets[block_pos.end.char_pos] - self.char_offsets[block_pos.start.char_pos]
        //     ).into());
        // }
        // let (start, end) = self.source_span_start_end(&block_pos, 0, 0);
        // Ok((start, end- start).into())
    }

    /// Get the raw YAML string.
    fn raw_yaml(&self) -> Cow<'static, str> {
        self.raw_yaml.clone()
    }
}

/// Parse simple XPath like "/groups/0/attributes/3".
///
/// Note: this is a very basic parser that only supports keys and array indices.
fn parse_xpath(xpath: &str) -> Result<Vec<PathComponent>, Error> {
    if !xpath.starts_with('/') {
        return Err(InvalidXPath {
            xpath: xpath.to_owned(),
            error: "XPath must start with '/'".to_owned(),
        });
    }

    let components: Result<Vec<_>, _> = xpath[1..] // Skip leading '/'
        .split('/')
        .filter(|s| !s.is_empty())
        .map(|component| {
            // Try to parse as number first (array index)
            if let Ok(index) = component.parse::<usize>() {
                Ok(PathComponent::Index(index))
            } else {
                Ok(PathComponent::Key(component.to_owned()))
            }
        })
        .collect();

    components
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_xpath_to_block_position() {
        let yaml = r##"groups:
  - name: long /
          name
    attributes:
      - attr1
      - attr2
      - attr3
  # Second group
  - name: group2
"##;
        let yaml = YamlDoc::try_from_string(yaml, "test.yaml").unwrap();

        let block_pos = yaml.xpath_to_block_position("/").unwrap();
        assert_eq!(block_pos.start.line, 1);
        assert_eq!(block_pos.end.line, 1);

        let block_pos = yaml.xpath_to_block_position("/groups").unwrap();
        assert_eq!(block_pos.start.line, 2);
        assert_eq!(block_pos.end.line, 2);

        let block_pos = yaml.xpath_to_block_position("/groups/0").unwrap();
        assert_eq!(block_pos.start.line, 2);
        assert_eq!(block_pos.end.line, 2);

        let block_pos = yaml.xpath_to_block_position("/groups/0/name").unwrap();
        assert_eq!(block_pos.start.line, 2);
        assert_eq!(block_pos.end.line, 3);

        let block_pos = yaml.xpath_to_block_position("/groups/1/name").unwrap();
        assert_eq!(block_pos.start.line, 9);
        assert_eq!(block_pos.end.line, 9);

        let block_pos = yaml
            .xpath_to_block_position("/groups/0/attributes")
            .unwrap();
        assert_eq!(block_pos.start.line, 5);
        assert_eq!(block_pos.end.line, 5);

        let block_pos = yaml
            .xpath_to_block_position("/groups/0/attributes/0")
            .unwrap();
        assert_eq!(block_pos.start.line, 5);
        assert_eq!(block_pos.end.line, 5);

        let block_pos = yaml
            .xpath_to_block_position("/groups/0/attributes/1")
            .unwrap();
        assert_eq!(block_pos.start.line, 6);
        assert_eq!(block_pos.end.line, 6);

        // Invalid XPath should return an error
        assert!(yaml
            .xpath_to_block_position("/groups/2/attributes/1")
            .is_err());
    }
}
