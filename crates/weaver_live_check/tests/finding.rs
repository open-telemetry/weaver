// SPDX-License-Identifier: Apache-2.0

//! Tests for generated finding types â€” kept separate from the definitions since
//! finding.rs is generated by Weaver from `model/live_check.yaml`.

use std::str::FromStr;

use weaver_live_check::{FindingId, SampleType, SignalType};

// === FindingId ===

#[test]
fn test_finding_id_roundtrip() {
    let variants = [
        FindingId::MissingAttribute,
        FindingId::TemplateAttribute,
        FindingId::MissingMetric,
        FindingId::MissingEvent,
        FindingId::Deprecated,
        FindingId::TypeMismatch,
        FindingId::NotStable,
        FindingId::UnitMismatch,
        FindingId::UnexpectedInstrument,
        FindingId::UndefinedEnumVariant,
        FindingId::RequiredAttributeNotPresent,
        FindingId::RecommendedAttributeNotPresent,
        FindingId::OptInAttributeNotPresent,
        FindingId::ConditionallyRequiredAttributeNotPresent,
        FindingId::MissingNamespace,
        FindingId::InvalidFormat,
        FindingId::IllegalNamespace,
        FindingId::ExtendsNamespace,
    ];
    for variant in &variants {
        let s = variant.to_string();
        let roundtripped = FindingId::from_str(&s).expect("parse failed");
        assert_eq!(&roundtripped, variant, "roundtrip failed for {s}");
    }
}

#[test]
fn test_finding_id_custom_variant() {
    let custom = FindingId::from_str("my_custom_policy").expect("parse failed");
    assert_eq!(custom, FindingId::Custom("my_custom_policy".to_owned()));
    assert_eq!(custom.to_string(), "my_custom_policy");
}

#[test]
fn test_finding_id_display() {
    assert_eq!(FindingId::TypeMismatch.to_string(), "type_mismatch");
    assert_eq!(FindingId::Custom("foo".to_owned()).to_string(), "foo");
}

#[test]
fn test_finding_id_into_string() {
    let s: String = FindingId::MissingAttribute.into();
    assert_eq!(s, "missing_attribute");
}

// === SampleType ===

#[test]
fn test_sample_type_roundtrip() {
    let variants = [
        SampleType::Attribute,
        SampleType::Span,
        SampleType::SpanEvent,
        SampleType::SpanLink,
        SampleType::Resource,
        SampleType::Metric,
        SampleType::NumberDataPoint,
        SampleType::HistogramDataPoint,
        SampleType::ExponentialHistogramDataPoint,
        SampleType::Exemplar,
        SampleType::Log,
    ];
    for variant in &variants {
        let s = variant.to_string();
        let roundtripped = SampleType::from_str(&s).expect("parse failed");
        assert_eq!(&roundtripped, variant, "roundtrip failed for {s}");
    }
}

#[test]
fn test_sample_type_display() {
    assert_eq!(SampleType::Attribute.to_string(), "attribute");
    assert_eq!(SampleType::SpanEvent.to_string(), "span_event");
    assert_eq!(
        SampleType::ExponentialHistogramDataPoint.to_string(),
        "exponential_histogram_data_point"
    );
}

#[test]
fn test_sample_type_is_copy() {
    let a = SampleType::Span;
    let b = a; // Copy
    assert_eq!(a, b);
}

// === SignalType ===

#[test]
fn test_signal_type_roundtrip() {
    let variants = [
        SignalType::Span,
        SignalType::Resource,
        SignalType::Metric,
        SignalType::Log,
    ];
    for variant in &variants {
        let s = variant.to_string();
        let roundtripped = SignalType::from_str(&s).expect("parse failed");
        assert_eq!(&roundtripped, variant, "roundtrip failed for {s}");
    }
}

#[test]
fn test_signal_type_display() {
    assert_eq!(SignalType::Span.to_string(), "span");
    assert_eq!(SignalType::Resource.to_string(), "resource");
    assert_eq!(SignalType::Metric.to_string(), "metric");
    assert_eq!(SignalType::Log.to_string(), "log");
}

#[test]
fn test_signal_type_is_copy() {
    let a = SignalType::Metric;
    let b = a; // Copy
    assert_eq!(a, b);
}
