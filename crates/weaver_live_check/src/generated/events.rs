// SPDX-License-Identifier: Apache-2.0
//! Generated event types and log record builders for live check findings.
//!
//! DO NOT EDIT — this file is generated by Weaver from `model/live_check.yaml`.
//! To regenerate, run from the repository root:
//!
//! ```sh
//! weaver registry generate \
//!   --registry crates/weaver_live_check/model/ \
//!   --templates crates/weaver_live_check/templates/ \
//!   --v2 \
//!   rust \
//!   crates/weaver_live_check/src/
//! ```
//!
//! Each `populate_*_log_record` function sets the event name, severity, body,
//! and all attributes on the record. Template-type attributes accept
//! `&[(Key, AnyValue)]` slices where each key is a suffix that gets prefixed
//! with the attribute's namespace constant.

use opentelemetry::logs::{AnyValue, LogRecord, Severity};
use opentelemetry::Key;

#[allow(clippy::wildcard_imports)]
use super::attributes::*;

/// Event name for: a semantic convention validation finding emitted by weaver live check
pub const WEAVER_LIVE_CHECK_FINDING: &str = "weaver.live_check.finding";

/// Populate a log record for the `weaver.live_check.finding` event.
///
/// This event is emitted when Weaver Live Check validates telemetry samples against
/// OpenTelemetry semantic conventions and detects violations, improvement opportunities,
/// or informational issues. Each finding represents a single policy check result.
///
/// The event body contains a human-readable message describing the finding, while
/// the attributes provide structured, machine-readable details for filtering,
/// aggregation, and automated processing.
///
/// Severity levels are mapped as follows:
///
/// - violation → ERROR severity
/// - improvement → WARN severity
/// - information → INFO severity
///
/// These findings can be collected via OTLP and analyzed to improve telemetry
/// quality, ensure semantic convention compliance, and identify instrumentation issues.
pub fn populate_finding_log_record(
    log_record: &mut impl LogRecord,
    body: impl Into<AnyValue>,
    severity: Severity,
    context: &[(Key, AnyValue)],
    id: &FindingId,
    level: &FindingLevel,
    resource_attribute: &[(Key, AnyValue)],
    sample_type: &SampleType,
    signal_name: Option<&str>,
    signal_type: Option<&SignalType>,
) {
    log_record.set_event_name(WEAVER_LIVE_CHECK_FINDING);
    log_record.set_severity_number(severity);
    log_record.set_severity_text(severity.name());
    log_record.set_body(body.into());
    for (suffix, value) in context {
        log_record.add_attribute(
            Key::from(format!("{}.{}", WEAVER_FINDING_CONTEXT, suffix.as_str())),
            value.clone(),
        );
    }
    log_record.add_attribute(Key::from(WEAVER_FINDING_ID), AnyValue::from(id.to_string()));
    log_record.add_attribute(
        Key::from(WEAVER_FINDING_LEVEL),
        AnyValue::from(level.to_string()),
    );
    for (suffix, value) in resource_attribute {
        log_record.add_attribute(
            Key::from(format!(
                "{}.{}",
                WEAVER_FINDING_RESOURCE_ATTRIBUTE,
                suffix.as_str()
            )),
            value.clone(),
        );
    }
    log_record.add_attribute(
        Key::from(WEAVER_FINDING_SAMPLE_TYPE),
        AnyValue::from(sample_type.to_string()),
    );
    if let Some(val) = signal_name {
        log_record.add_attribute(
            Key::from(WEAVER_FINDING_SIGNAL_NAME),
            AnyValue::from(val.to_owned()),
        );
    }
    if let Some(val) = signal_type {
        log_record.add_attribute(
            Key::from(WEAVER_FINDING_SIGNAL_TYPE),
            AnyValue::from(val.to_string()),
        );
    }
}
